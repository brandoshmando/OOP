OBJECT ORIENTED PROGRAMMING

Procedural Programming: Line by line, that is the way the the program executes...
	-pass data around
	-C

Object Oriented came around	
	-create stand-alone objects that represent real world things ie interacting or talking with each other, have different/separate states
	-SmallTalk was the OG OOP lang

	Functional Programming
		-pass functions around that call each other all the time
		-math based
		-possibility of more elegant code
		-clojure, javascript

Benefit of OOP: Write code that is similar to problem space (industry you are coding for)

Object?
-Car
-Boat
-Bank account
-Window

All have different properties
Anything!!!

Object parts
-Name
-State
-Behavior
Must have a state and behavior to be an Object

Object Name
-Likely a variable in this case

Object State
ex Gas tank
-current price
-fuel level
-empty?

Object Behavior
-fill tank
-dispense gas

Bank Account
-state: balance
-behavior: deposit, withdraw

Note: You can tell an object what to do, and it should know all of its behaviors within itself. Separation of concerns. 
	Ex: Car, radio, wheels
		all separate objects that know their own behaviors (classes?)

MESSAGE PASSING
	-We are telling an object to do something. If an object does not know a way to execute a behavior, throws no method error

	Data encapsulation
	 -State is usually kept private ie data
	 -behavior is always public ie we want everyone to be able to tell our object what to do
	 -to access or change data, you have to use a method. That method must be included within object

	 Tell an object to perform a task

	 Ask the object for its data and perform task else where

CLASSES AND OBJECTS

Class: a blueprint for an object. "The idea of what and object would look like." 																		"The concept of a dog (class Dog)"
				Caveat: Class is technically not an object but rather a class object (more later)
Instance: The actual object created from the "blue print" the object (.new)

		-Instance variable @var: the value (whatever it is set as in initialize) of this variable always sticks around with that particular instance of a class 
	<% 
	class Point
		def initialize(x, y)
			@x = x
			@y = y
		end
		#getter method to output info to user
		def x 
			@x
		end

		def y
			@y
		end

		#setter method so user can set method
		def x=(x)
			@x = x 
		end

		def y=(y)
			@y = y
		end
	#attr_reader is shortcut to getter method
	#attr_writer is shortcut to setter method
	#attr_accessor is shortcut to both

	end

	p = Point.new(x, y)

	p.x # calls getter
	p.x = 5 #calls setter
	%>

	With attr example:
	<%
	class Point
	attr_accessor :x, :y #creates getter and setter methods for :x and :y
	def initialize(x, y)
		@x = x
		@y = y
	end
end

p = Point.new(x, y)

p.x # calls getter
p.x = 5 #calls setter
%>

Adding and add method..
<%
class Point
	attr_reader :x, :y #creates getter and setter methods for :x and :y
	def initialize(x, y)
		@x = x
		@y = y
	end
	def +(another_point)
		Point.new(@x+ another_point.x, @y + another_point.y)
	end

	def to_s
		"(#{@x}, #{@y})"
	end
end

p = Point.new(1, 2)

p1 = Point.new(1,2)
p2 = Point.new(2, 5)

p3 = p1 + p2
puts p3
%>

Super within a method tells it to go look in its parent for a method of the same name, and call it. You can leave it there or add on to it from there.

<%
class Point
	attr_reader :x, :y #creates getter and setter methods for :x and :y
	def initialize(x, y)
		@x = x
		@y = y
	end
	def +(another_point)
		Point.new(@x+ another_point.x, @y + another_point.y)
	end

	def to_s
		"(#{x}, #{y})"
	end
end

class Line
	attr_reader :start_point, :end_point
	def initialize(start_point, end_point)
		@start_point = start_point
		@end_point = end_point
	end

	def to_s
		"#{start_point.to_s} == #{end_point.to_s}"
	end
end

class Vector < Line 
	attr_reader :direction
	def initialize(start_point, end_point, direction)
		super(start_point, end_point) #reuses parents initializer
		@direction = direction
	end

	def to_s
		super + "-> #{direction}"
	end
end


p1 = Point.new(1, 2)
p2 = Point.new(2, 5)
l = Line.new(p1, p2)
puts l

vector = Vector.new(p1, p2, 5) 
puts vector

p3 = p1 + p2
puts p3
%>



